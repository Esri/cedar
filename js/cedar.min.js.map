{"version":3,"file":"cedar.min.js","sources":["../../src/cedar.js"],"names":["window","Cedar","options","self","this","opts","_events","_definition","_defaultDefinition","_view","undefined","_methodQueue","_pendingXhr","definition","Error","getJson","err","data","_purgeMethodQueue","override","specification","dataset","defaultQuery","_defaultQuery","query","_","defaults","Object","defineProperty","get","set","val","prototype","canDraw","drawable","errs","show","_addToMethodQueue","elementId","d3","select","_elementId","_renderer","renderer","token","_token","chk","issues","join","update","_remove","compiledMappings","_applyDefaultsToMappings","mappings","inputs","spec","JSON","parse","_supplant","stringify","template","_mergeRecursive","url","values","_renderSpec","_createFeatureServiceRequest","cb","console","dir","ex","vg","chartCtor","el","_attach","opt","view","items","model","scene","forEach","item","datum","attributes","key","value","hasPropertySet","props","on","_handler","off","_validateMappings","input","missingInputs","i","length","required","name","push","_validateData","features","Array","isArray","firstRow","fld","_getMappingFieldName","field","hasOwnProperty","mappingName","fieldName","toLowerCase","defn","where","returnGeometry","returnDistinctValues","returnIdsOnly","returnCountOnly","outFields","f","evtName","handler","evt","registeredHandler","type","callback","log","args","method","action","apply","json","message","mergedQuery","clone","bbox","geometry","bboxArr","split","xmin","ymin","xmax","ymax","inSR","group","groupByFieldsForStatistics","count","orderByFields","outStatistics","statisticType","onStatisticField","outStatisticFieldName","sort","_serializeQueryParams","default","tmpl","params","replace","a","b","r","_getTokenValue","obj1","obj2","p","constructor","e","tokens","tokenName","tmpTokens","tokenNameParts","str","encodeURIComponent","queryString"],"mappings":"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","sourcesContent":["/**\n * Cedar\n *\n * Generic charting / visualization library for the ArcGIS Platform\n * that leverages vega + d3 internally.\n */\n\n(function(window){\n  'use strict';\n\n/**\n * Constructor\n * @param {object} options Cedar options\n */\nvar Cedar = function Cedar(options){\n  //close over this for use in callbacks\n  var self = this;\n\n  //ensure an opts object\n  var opts = options || {};\n\n  /**\n   * Internals for holding state\n   */\n  \n\n  // Array to hold event handlers\n  this._events = [];\n\n  //initialize the internal definition hash\n  this._definition = Cedar._defaultDefinition();\n\n  //the vega view aka the chart\n  this._view = undefined;\n\n  //queue to hold methods called while\n  //xhrs are in progress\n  this._methodQueue=[];\n\n  /**\n   * Flag used to determine if the library is\n   * waiting for an xhr to return. \n   */\n  this._pendingXhr = false;\n\n  //defintion \n  if(opts.definition){\n    //is it an object or string(assumed to be url)\n    if(typeof opts.definition === 'object'){\n      //hold onto the definition\n      this._definition = opts.definition;\n    }else if(typeof opts.definition === 'string' ){ \n      //assume it's a url (relative or abs) and fetch the definition object\n      this._pendingXhr = true;\n      Cedar.getJson(opts.definition, function(err,data){\n        self._pendingXhr = false;\n        self._definition = data; \n        self._purgeMethodQueue();\n      });\n    }else{\n      throw new Error('parameter definition must be an object or string (url)');\n    }\n  }\n\n  if(opts.override) {\n    this._definition.override = opts.override;\n  }\n\n  //template\n  if(opts.specification){\n    //is it an object or string(assumed to be url)\n    if(typeof opts.specification === 'object'){\n      //hold onto the template\n      this._definition.specification = opts.specification;\n\n    }else if(typeof opts.specification === 'string' ){ \n      //assume it's a url (relative or abs) and fetch the template object\n      this._pendingXhr = true;\n      Cedar.getJson(opts.specification, function(err,data){\n        self._pendingXhr = false;\n        self._definition.specification = data; \n        self._purgeMethodQueue();\n      });\n    }else{\n      throw new Error('parameter template must be an object or string (url)');\n    }\n  }\n\n  //allow a dataset to be passed in...\n  if(opts.dataset && typeof opts.dataset === 'object'){\n    var defaultQuery = Cedar._defaultQuery();\n\n    if(!opts.dataset.query){\n      opts.dataset.query = defaultQuery;\n    }else{\n      opts.dataset.query = _.defaults(opts.dataset.query, defaultQuery);\n    }\n    //assign it\n    this._definition.dataset = opts.dataset;\n  }\n\n  /**\n   * Properties\n   *\n   * ES 5.1 syntax, so IE 8 & lower won't work\n   * \n   * If the val is a url, should we expect\n   * cedar to fetch the object? \n   * \n   * I'd say no... as that violates the principal \n   * of least suprise. Also - cedar has a .getJSON\n   * helper method the dev should use.\n   * \n   */\n      \n  Object.defineProperty(this, 'dataset', {\n    get: function() {\n        return this._definition.dataset;\n    },\n    set: function(val) {\n       this._definition.dataset = val;\n    }\n  });\n\n  Object.defineProperty(this, 'specification', {\n    get: function() {\n        return this._definition.specification;\n    },\n    set: function(val) {\n      this._definition.specification = val;\n    }\n  });\n\n  Object.defineProperty(this, 'override', {\n    get: function() {\n        return this._definition.override;\n    },\n    set: function(val) {\n      this._definition.override = val;\n    }\n  });  \n\n};\n\n\n/**\n * Inspect the current state of the object\n * and determine if we have sufficient information\n * to render the chart\n * @return {object} Hash of the draw state + any missing requirements\n */\nCedar.prototype.canDraw = function(){\n\n  //dataset?\n  //dataset.url || dataset.data?\n  //dataset.mappings?\n  //specification?\n  //specification.template?\n  //specification.inputs?\n  //specification.inputs ~ dataset.mappings?\n  \n  return {drawable:true, errs:[]};\n\n};\n\n/**\n * Render a chart in the specified element\n * @param  {object} options \n * \n * options.elementId [required] Id of the Dom element into which the chart will be rendered\n * options.token     [optional] Token to be used if the data or spec are on a secured server\n */\nCedar.prototype.show = function(options){\n  if(this._pendingXhr){\n    \n    this._addToMethodQueue('show', [options]);\n\n  }else{\n\n    var err;\n    //ensure we got an elementId\n    if( !options.elementId ){\n      err= \"Cedar.show requires options.elementId\";\n    }\n    //check if element exists in the page\n    if(d3.select(options.elementId)[0][0] === null){\n      err = \"Element \" + options.elementId + \" is not present in the DOM\";\n     }\n  \n    //hold onto the id\n    this._elementId = options.elementId;\n    this._renderer = options.renderer || \"canvas\"; //default to canvas\n\n    //hold onto the token\n    if(options.token){\n      this._token = options.token;\n    }\n\n    if( err ){\n      throw new Error( err );\n    }\n    var chk = this.canDraw();\n    if(chk.drawable){\n      //update centralizes the spec compilation & drawing\n      this.update();  \n    }else{\n      //report the issues\n      var errs = chk.issues.join(',');\n      throw new Error('Chart can not be drawn because: ' + errs);  \n    }\n    \n  }\n};\n\n/**\n * Render the chart using the internal state\n * Should be called after a user modifies the \n * of the dataset, query, mappings or template\n */\nCedar.prototype.update = function(){\n  var self = this;\n  \n  if(this._pendingXhr){\n    \n    this._addToMethodQueue('update');\n\n  }else{\n\n    if(this._view){\n      //remove handlers\n      //TODO Remove existing handlers\n      this._remove(this._view);\n    }\n    try{\n      //ensure we have required inputs or defaults \n      var compiledMappings = Cedar._applyDefaultsToMappings(this._definition.dataset.mappings, this._definition.specification.inputs); //Cedar._compileMappings(this._definition.dataset, this._definition.specification.inputs);\n\n      //compile the template + mappings --> vega spec\n      var spec = JSON.parse(Cedar._supplant(JSON.stringify(this._definition.specification.template), compiledMappings)); \n\n      // merge in user specified style overrides\n      spec = Cedar._mergeRecursive(spec, this._definition.override);\n\n      //if the spec has a url in the data node, delete it\n      if(spec.data[0].url){\n        delete spec.data[0].url;\n      }\n\n      if(this._definition.dataset.data){\n\n        //create the data node using the passed in data\n        spec.data[0].values = this._definition.dataset.data;\n        \n        //send to vega\n        this._renderSpec(spec);\n      \n      }else{\n      \n        //we need to fetch the data so\n        var url = Cedar._createFeatureServiceRequest(this._definition.dataset);\n      \n        //create a callback closure to carry the spec\n        var cb = function(err,data){\n      \n          //todo add error handlers for xhr and ags errors\n          spec.data[0].values = data;\n          console.dir(spec);\n          //send to vega\n          self._renderSpec(spec);\n        };\n\n        //fetch the data from the service\n        Cedar.getJson(url, cb);\n      }\n    }\n    catch(ex){\n      throw(ex);\n    }\n  }\n};\n\n\n/**\n * Render a fully cooked spec\n */\nCedar.prototype._renderSpec = function(spec){\n  var self = this;\n  try{\n    //use vega to parse the spec \n    //it will handle the spec as an object or url\n    vg.parse.spec(spec, function(chartCtor) { \n\n      //create the view\n      self._view = chartCtor({\n        el: self._elementId,\n        renderer: self._renderer\n      });\n\n      \n      //render into the element\n      self._view.update(); \n\n      //attach event proxies\n      self._attach(self._view);\n\n    });\n  }\n  catch(ex){\n    throw(ex);\n  }\n};\n\n/**\n * highlight marker based on attribute value\n */\nCedar.prototype.select = function( opt ) {\n  var self = this;\n  var view = this._view;\n  var items = view.model().scene().items[0].items[0].items;\n\n  items.forEach(function(item) {\n    if ( item.datum.data.attributes[opt.key] === opt.value ) {\n      if ( item.hasPropertySet(\"hover\") ) {\n        self._view.update({props:\"hover\", items:item});\n      }\n    }\n  });\n\n};\n\n\n/**\n * Attach the generic proxy handlers to the chart view\n */\nCedar.prototype._attach = function(view){\n\n  view.on('mouseover', this._handler('mouseover'));\n  view.on('mouseout', this._handler('mouseout'));\n  view.on('click', this._handler(\"click\"));\n  \n};\n\n/**\n * Remove all event handlers from the view\n */\nCedar.prototype._remove = function(view){\n\n  view.off('mouseover');\n  view.off('mouseout');\n  view.off('click');\n  \n};\n\n/**\n * Helper function that validates that the \n * mappings hash contains values for all\n * the inputs\n * @param  {array} inputs   Array of inputs\n * @param  {object} mappings Hash of mappings\n * @return {array}          Missing mappings\n */\nCedar._validateMappings = function(inputs, mappings){\n  var missingInputs = [], input;\n  for(var i=0;i<inputs.length;i++){\n    input = inputs[i];\n    if(input.required){\n      if(!mappings[input.name]){\n        missingInputs.push(input.name);\n      }\n    }\n  }\n  return missingInputs;\n};\n\n/**\n * Validate that the incoming data has the fields expected\n * in the mappings\n */\nCedar._validateData = function(data, mappings){\n  var missingInputs = [];\n  if(!data.features || !Array.isArray(data.features)){\n    throw new Error('Data is expected to have features array!');\n  }\n  var firstRow = data.features[0].attributes;\n  for(var key in mappings){\n    var fld = Cedar._getMappingFieldName(key, mappings[key].field);\n    if(!firstRow.hasOwnProperty(fld)){\n      missingInputs.push(fld);\n    }\n  }\n  return missingInputs;\n};\n\n/**\n * Centralize and abstract the computation of\n * expected field names, based on the mapping name\n */\nCedar._getMappingFieldName = function(mappingName, fieldName){\n  var name = fieldName;\n  if(mappingName.toLowerCase() === 'count'){\n    name = fieldName + '_SUM';\n  }\n  return name;\n};\n\n/**\n * Return a default definition object\n */\nCedar._defaultDefinition = function(){\n  var defn = {\n    \"dataset\": {\n      \"query\": this._defaultQuery()\n    },\n    \"template\":{}\n  };\n\n  defn.dataset.query = Cedar._defaultQuery();\n\n  return defn;\n};\n\n/**\n * Default Query Object\n */\nCedar._defaultQuery = function(){\n  var defaultQuery = {\n    \"where\": \"1=1\",\n    \"returnGeometry\": false,\n    \"returnDistinctValues\": false,\n    \"returnIdsOnly\": false,\n    \"returnCountOnly\": false,\n    \"outFields\": \"*\",\n    \"f\": \"json\"\n  };\n  return defaultQuery;\n};\n\n\n\n/**\n * Generic event handler proxy\n */\nCedar.prototype._handler = function(evtName) {\n  var self = this;\n  //return a handler function w/ the events hash closed over\n  var handler = function(evt, item){\n    self._events.forEach( function(registeredHandler){\n      if(registeredHandler.type === evtName){\n        //invoke the callback with the data\n        registeredHandler.callback(item.datum.data.attributes);\n      }\n    });\n  };\n  return handler;\n};\n\n/**\n * Add a handler for the named event\n */\nCedar.prototype.on = function(evtName, callback){\n  this._events.push({\"type\":evtName, \"callback\":callback});\n};\n\n/**\n * Remove a handler for the named event\n */\nCedar.prototype.off = function(evtName /*, callback */){\n  console.log('Handler for ' + evtName +' removed...');\n};\n\n\n/**\n * Creates an entry in the method queue, excuted \n * once a pending xhr is completed \n */\nCedar.prototype._addToMethodQueue = function(name, args){\n  this._methodQueue.push({ method: name, args: args });\n};\n\n/**\n * empties the method queue by calling the queued methods\n * This helps build a more syncronous api, while still\n * doing async things in the code\n */\nCedar.prototype._purgeMethodQueue = function(){\n  var self = this;\n  if(self._methodQueue.length > 0){\n\n    for(var i=0;i<self._methodQueue.length;i++){\n      var action = self._methodQueue[i];\n      self[action.method].apply(self, action.args);  \n    }\n  }\n};\n\n/**\n * fetch json from a url\n * @param  {string}   url      Url to json file\n * @param  {Function} callback node-style callback function (err, data)\n */\nCedar.getJson = function( url, callback ){\n  d3.json(url, function(err,data) {\n    if(err){\n      callback('Error loading ' + url + ' ' + err.message);\n    }\n    callback(null, data);\n  });\n};\n\n\n\n\n/**\n * Given a dataset hash, create the feature service\n * query string\n */\n\nCedar._createFeatureServiceRequest = function( dataset ){\n  var mergedQuery;\n  //ensure that we have a query\n  if(dataset.query){\n    mergedQuery = _.clone(dataset.query);\n    //ensure we have all needed properties on the query\n    //TODO: use a microlib instead of underscore\n    _.defaults(mergedQuery, Cedar._defaultQuery());\n  }else{\n    mergedQuery = Cedar._defaultQuery();\n  }\n  //Handle bbox\n  if(mergedQuery.bbox){\n    //make sure a geometry was not also passed in\n    if(mergedQuery.geometry){\n      throw new Error('Dataset.query can not have both a geometry and a bbox specified');\n    }\n    //get the bbox (W,S,E,N)\n    var bboxArr = mergedQuery.bbox.split(',');\n\n    //remove it so it's not serialized as-is\n    delete mergedQuery.bbox;\n\n    //cook it into a json string \n    mergedQuery.geometry = JSON.stringify({\"xmin\": bboxArr[0], \"ymin\": bboxArr[2],\"xmax\": bboxArr[1], \"ymax\": bboxArr[3] });\n    //set the spatial ref as geographic\n    mergedQuery.inSR = '4326';\n  }\n  if(dataset.mappings.group) {\n      mergedQuery.groupByFieldsForStatistics = dataset.mappings.group.field;\n  }\n  if(dataset.mappings.count) {\n    mergedQuery.orderByFields = dataset.mappings.count.field + \"_SUM\";\n    mergedQuery.outStatistics = JSON.stringify([{\"statisticType\": \"sum\", \"onStatisticField\": dataset.mappings.count.field, \"outStatisticFieldName\": dataset.mappings.count.field + \"_SUM\"}]);\n  }\n\n\n\n  //iterate the mappings keys to check for sort\n  //-----------------------------------------------------------------\n  //This approach would seem 'clean' but if there are multiple fields\n  //to sort by, the order would be determined by how javascript decides to\n  //iterate the mappings property hash.\n  //Thus, using mappings.sort gives the developer explicit control\n  //-----------------------------------------------------------------\n  // var sort = [];\n  // for (var property in dataset.mappings) {\n  //   if (dataset.mappings.hasOwnProperty(property)) {\n  //     if(dataset.mappings[property].sort){\n  //       //ok - build up the sort\n  //       sort.push(dataset.mappings[property].field + ' ' + dataset.mappings[property].sort);\n  //     }\n  //   }\n  // }\n  // if(sort.length > 0){\n  //   mergedQuery.orderByFields = sort.join(',');\n  // }\n  //-----------------------------------------------------------------\n  //check for a sort passed directly in\n  if(dataset.mappings.sort){\n    mergedQuery.orderByFields = dataset.mappings.sort;\n  }\n\n  var url = dataset.url + \"/query?\" + this._serializeQueryParams(mergedQuery);\n  \n  if(dataset.token){\n    url = url + '&token=' + dataset.token;\n  }\n  \n  return url;\n};\n\nCedar._applyDefaultsToMappings = function(mappings, inputs){\n  var errs = [];\n  //loop over the inputs\n  for(var i =0; i < inputs.length; i++){\n    //get the input\n    var input = inputs[i];\n\n    //if it's required and not in the mappings, add an exception\n    if(input.required && !mappings[input.name] ){\n      errs.push(input.name);\n    }\n    \n    //if it's not required, has a default and not in the mappings\n    if(!input.required && !mappings[input.name] && input.default){\n      //add the default\n      mappings[input.name] = input.default;\n    }\n  }\n\n  if(errs.length > 0){\n    throw new Error('Required Mappings Missing: ' + errs.join(','));\n  }else{\n    return mappings;\n  }\n};\n\n\n/**\n * Token Replacement on a string\n * @param  {string} template string template\n * @param  {object} params   object hash that maps to the tokens to be replaced\n * @return {string}          string with values replaced\n */\nCedar._supplant = function( tmpl, params ){\n  console.log('Mappings: ', params);\n  return tmpl.replace(/{([^{}]*)}/g,\n    function (a, b) {\n      var r = Cedar._getTokenValue(params, b);\n      return typeof r === 'string' || typeof r === 'number' ? r : a;\n    }\n  );\n};\n\n/*\n* Recursively merge properties of two objects \n*/\nCedar._mergeRecursive = function(obj1, obj2) {\n  for (var p in obj2) {\n    try {\n      // Property in destination object set; update its value.\n      if ( obj2[p].constructor===Object || obj2[p].constructor===Array) {\n        obj1[p] = Cedar._mergeRecursive(obj1[p], obj2[p]);\n\n      } else {\n        obj1[p] = obj2[p];\n\n      }\n\n    } catch(e) {\n      // Property in destination object not set; create it and set its value.\n      obj1[p] = obj2[p];\n\n    }\n  }\n\n  return obj1;\n};\n\n/**\n * Get the value of a token from a hash\n * @param  {[type]} tokens    [description]\n * @param  {[type]} tokenName [description]\n * @return {[type]}           [description]\n * Pulled from gulp-token-replace (MIT license)\n * https://github.com/Pictela/gulp-token-replace/blob/master/index.js\n * \n */\nCedar._getTokenValue = function(tokens, tokenName) {\n  var tmpTokens = tokens;\n  var tokenNameParts = tokenName.split('.');\n  for (var i = 0; i < tokenNameParts.length; i++) {\n    if (tmpTokens.hasOwnProperty(tokenNameParts[i])) {\n      tmpTokens = tmpTokens[tokenNameParts[i]];\n    } else {\n      return null;\n    }\n  }\n  return tmpTokens;\n};\n\n/**\n * Serilize an object into a query string\n * @param  {object} params Params for the query string\n * @return {string}        query string\n */\nCedar._serializeQueryParams = function(params) {\n  var str = [];\n  for(var p in params){\n    if (params.hasOwnProperty(p)) {\n      str.push(encodeURIComponent(p) + \"=\" + encodeURIComponent(params[p]));\n    }\n  }\n  var queryString = str.join(\"&\");\n  return queryString;\n};\n\nwindow.Cedar = Cedar;\n\n})(window);"]}